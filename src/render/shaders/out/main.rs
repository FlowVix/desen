pub mod globals { # [allow (unused_imports)] pub use super :: * ; # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup1EntriesEntriesParams < '__lt > { pub TEX_T : & '__lt wgpu :: TextureView , pub TEX_S : & '__lt wgpu :: Sampler } # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup1Entries < '__lt > { pub TEX_T : wgpu :: BindGroupEntry < '__lt > , pub TEX_S : wgpu :: BindGroupEntry < '__lt > } impl < '__lt > BindGroup1Entries < '__lt > { pub fn new (params : BindGroup1EntriesEntriesParams < '__lt >) -> Self { Self { TEX_T : wgpu :: BindGroupEntry { binding : 0u32 , resource : wgpu :: BindingResource :: TextureView (params . TEX_T) } , TEX_S : wgpu :: BindGroupEntry { binding : 1u32 , resource : wgpu :: BindingResource :: Sampler (params . TEX_S) } } } } # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup1 (wgpu :: BindGroup) ; impl BindGroup1 { pub const INDEX : u32 = 1u32 ; # [allow (unused_doc_comments)] pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("main::BindGroup1::LayoutDescriptor") , entries : & [# [doc = "@binding(1): TEX_T"] wgpu :: BindGroupLayoutEntry { binding : 0u32 , visibility : wgpu :: ShaderStages :: VERTEX_FRAGMENT , ty : wgpu :: BindingType :: Texture { sample_type : wgpu :: TextureSampleType :: Float { filterable : true } , view_dimension : wgpu :: TextureViewDimension :: D2 , multisampled : false , } , count : None , } , # [doc = "@binding(1): TEX_S"] wgpu :: BindGroupLayoutEntry { binding : 1u32 , visibility : wgpu :: ShaderStages :: VERTEX_FRAGMENT , ty : wgpu :: BindingType :: Sampler (wgpu :: SamplerBindingType :: Filtering) , count : None , }] , } ; pub fn get_bind_group_layout (device : & wgpu :: Device) -> wgpu :: BindGroupLayout { device . create_bind_group_layout (& Self :: LAYOUT_DESCRIPTOR) } pub fn from_bindings (device : & wgpu :: Device , bindings : BindGroup1Entries ,) -> Self { let bind_group_layout = Self :: get_bind_group_layout (& device) ; let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("main::BindGroup1") , layout : & bind_group_layout , entries : & [bindings . TEX_T , bindings . TEX_S] , } ,) ; Self (bind_group) } pub fn get_bind_group (& self) -> & wgpu :: BindGroup { & self . 0 } } # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup2EntriesEntriesParams < '__lt > { pub TEXT_MASK_T : & '__lt wgpu :: TextureView , pub TEXT_COLOR_T : & '__lt wgpu :: TextureView , pub TEXT_MASK_S : & '__lt wgpu :: Sampler , pub TEXT_COLOR_S : & '__lt wgpu :: Sampler } # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup2Entries < '__lt > { pub TEXT_MASK_T : wgpu :: BindGroupEntry < '__lt > , pub TEXT_COLOR_T : wgpu :: BindGroupEntry < '__lt > , pub TEXT_MASK_S : wgpu :: BindGroupEntry < '__lt > , pub TEXT_COLOR_S : wgpu :: BindGroupEntry < '__lt > } impl < '__lt > BindGroup2Entries < '__lt > { pub fn new (params : BindGroup2EntriesEntriesParams < '__lt >) -> Self { Self { TEXT_MASK_T : wgpu :: BindGroupEntry { binding : 0u32 , resource : wgpu :: BindingResource :: TextureView (params . TEXT_MASK_T) } , TEXT_COLOR_T : wgpu :: BindGroupEntry { binding : 2u32 , resource : wgpu :: BindingResource :: TextureView (params . TEXT_COLOR_T) } , TEXT_MASK_S : wgpu :: BindGroupEntry { binding : 1u32 , resource : wgpu :: BindingResource :: Sampler (params . TEXT_MASK_S) } , TEXT_COLOR_S : wgpu :: BindGroupEntry { binding : 3u32 , resource : wgpu :: BindingResource :: Sampler (params . TEXT_COLOR_S) } } } } # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup2 (wgpu :: BindGroup) ; impl BindGroup2 { pub const INDEX : u32 = 2u32 ; # [allow (unused_doc_comments)] pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("main::BindGroup2::LayoutDescriptor") , entries : & [# [doc = "@binding(2): TEXT_MASK_T"] wgpu :: BindGroupLayoutEntry { binding : 0u32 , visibility : wgpu :: ShaderStages :: VERTEX_FRAGMENT , ty : wgpu :: BindingType :: Texture { sample_type : wgpu :: TextureSampleType :: Float { filterable : true } , view_dimension : wgpu :: TextureViewDimension :: D2 , multisampled : false , } , count : None , } , # [doc = "@binding(2): TEXT_COLOR_T"] wgpu :: BindGroupLayoutEntry { binding : 2u32 , visibility : wgpu :: ShaderStages :: VERTEX_FRAGMENT , ty : wgpu :: BindingType :: Texture { sample_type : wgpu :: TextureSampleType :: Float { filterable : true } , view_dimension : wgpu :: TextureViewDimension :: D2 , multisampled : false , } , count : None , } , # [doc = "@binding(2): TEXT_MASK_S"] wgpu :: BindGroupLayoutEntry { binding : 1u32 , visibility : wgpu :: ShaderStages :: VERTEX_FRAGMENT , ty : wgpu :: BindingType :: Sampler (wgpu :: SamplerBindingType :: Filtering) , count : None , } , # [doc = "@binding(2): TEXT_COLOR_S"] wgpu :: BindGroupLayoutEntry { binding : 3u32 , visibility : wgpu :: ShaderStages :: VERTEX_FRAGMENT , ty : wgpu :: BindingType :: Sampler (wgpu :: SamplerBindingType :: Filtering) , count : None , }] , } ; pub fn get_bind_group_layout (device : & wgpu :: Device) -> wgpu :: BindGroupLayout { device . create_bind_group_layout (& Self :: LAYOUT_DESCRIPTOR) } pub fn from_bindings (device : & wgpu :: Device , bindings : BindGroup2Entries ,) -> Self { let bind_group_layout = Self :: get_bind_group_layout (& device) ; let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("main::BindGroup2") , layout : & bind_group_layout , entries : & [bindings . TEXT_MASK_T , bindings . TEXT_COLOR_T , bindings . TEXT_MASK_S , bindings . TEXT_COLOR_S] , } ,) ; Self (bind_group) } pub fn get_bind_group (& self) -> & wgpu :: BindGroup { & self . 0 } } # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup0EntriesEntriesParams < '__lt > { pub GLOBALS : wgpu :: BufferBinding < '__lt > } # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup0Entries < '__lt > { pub GLOBALS : wgpu :: BindGroupEntry < '__lt > } impl < '__lt > BindGroup0Entries < '__lt > { pub fn new (params : BindGroup0EntriesEntriesParams < '__lt >) -> Self { Self { GLOBALS : wgpu :: BindGroupEntry { binding : 0u32 , resource : wgpu :: BindingResource :: Buffer (params . GLOBALS) } } } } # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup0 (wgpu :: BindGroup) ; impl BindGroup0 { pub const INDEX : u32 = 0u32 ; # [allow (unused_doc_comments)] pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("main::BindGroup0::LayoutDescriptor") , entries : & [# [doc = "@binding(0): GLOBALS"] wgpu :: BindGroupLayoutEntry { binding : 0u32 , visibility : wgpu :: ShaderStages :: VERTEX_FRAGMENT , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < super :: structs :: Globals > () as _) , } , count : None , }] , } ; pub fn get_bind_group_layout (device : & wgpu :: Device) -> wgpu :: BindGroupLayout { device . create_bind_group_layout (& Self :: LAYOUT_DESCRIPTOR) } pub fn from_bindings (device : & wgpu :: Device , bindings : BindGroup0Entries ,) -> Self { let bind_group_layout = Self :: get_bind_group_layout (& device) ; let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("main::BindGroup0") , layout : & bind_group_layout , entries : & [bindings . GLOBALS] , } ,) ; Self (bind_group) } pub fn get_bind_group (& self) -> & wgpu :: BindGroup { & self . 0 } } # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup3EntriesEntriesParams < '__lt > { pub CLIP_POLYGON_POINTS : wgpu :: BufferBinding < '__lt > , pub CLIP_POLYGONS : wgpu :: BufferBinding < '__lt > } # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup3Entries < '__lt > { pub CLIP_POLYGON_POINTS : wgpu :: BindGroupEntry < '__lt > , pub CLIP_POLYGONS : wgpu :: BindGroupEntry < '__lt > } impl < '__lt > BindGroup3Entries < '__lt > { pub fn new (params : BindGroup3EntriesEntriesParams < '__lt >) -> Self { Self { CLIP_POLYGON_POINTS : wgpu :: BindGroupEntry { binding : 0u32 , resource : wgpu :: BindingResource :: Buffer (params . CLIP_POLYGON_POINTS) } , CLIP_POLYGONS : wgpu :: BindGroupEntry { binding : 1u32 , resource : wgpu :: BindingResource :: Buffer (params . CLIP_POLYGONS) } } } } # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup3 (wgpu :: BindGroup) ; impl BindGroup3 { pub const INDEX : u32 = 3u32 ; # [allow (unused_doc_comments)] pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("main::BindGroup3::LayoutDescriptor") , entries : & [# [doc = "@binding(3): CLIP_POLYGON_POINTS"] wgpu :: BindGroupLayoutEntry { binding : 0u32 , visibility : wgpu :: ShaderStages :: VERTEX_FRAGMENT , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = "@binding(3): CLIP_POLYGONS"] wgpu :: BindGroupLayoutEntry { binding : 1u32 , visibility : wgpu :: ShaderStages :: VERTEX_FRAGMENT , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ; pub fn get_bind_group_layout (device : & wgpu :: Device) -> wgpu :: BindGroupLayout { device . create_bind_group_layout (& Self :: LAYOUT_DESCRIPTOR) } pub fn from_bindings (device : & wgpu :: Device , bindings : BindGroup3Entries ,) -> Self { let bind_group_layout = Self :: get_bind_group_layout (& device) ; let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("main::BindGroup3") , layout : & bind_group_layout , entries : & [bindings . CLIP_POLYGON_POINTS , bindings . CLIP_POLYGONS] , } ,) ; Self (bind_group) } pub fn get_bind_group (& self) -> & wgpu :: BindGroup { & self . 0 } } } pub mod constants { # [allow (unused_imports)] pub use super :: * ; } pub mod structs { # [allow (unused_imports)] pub use super :: * ; # [allow (non_snake_case)] # [repr (C , align (8))] # [cfg_attr (debug_assertions , derive (Debug))] # [derive (PartialEq , Clone , Copy , Default , bytemuck :: Pod , bytemuck :: Zeroable)] pub struct Globals { # [doc = "size: 8, offset: 0x0, type: `vec2<f32>`"] pub screen_size : [f32 ; 2usize] } impl Globals { pub fn new (screen_size : [f32 ; 2usize]) -> Self { Self { screen_size } } } # [allow (non_snake_case)] # [repr (C)] # [cfg_attr (debug_assertions , derive (Debug))] # [derive (PartialEq , Clone , Copy , Default , bytemuck :: Pod , bytemuck :: Zeroable)] pub struct VertexInput { pub pos : [f32 ; 2usize] } impl VertexInput { pub fn new (pos : [f32 ; 2usize]) -> Self { Self { pos } } } impl super :: super :: main :: structs :: VertexInput { pub fn vertex_desc (step_mode : wgpu :: VertexStepMode) -> wgpu :: VertexBufferLayout < 'static > { wgpu :: VertexBufferLayout { array_stride : std :: mem :: size_of :: < Self > () as wgpu :: BufferAddress , step_mode , attributes : & [wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , pos) as wgpu :: BufferAddress , shader_location : 0u32 , format : wgpu :: VertexFormat :: Float32x2 , }] , } } } # [allow (non_snake_case)] # [repr (C)] # [cfg_attr (debug_assertions , derive (Debug))] # [derive (PartialEq , Clone , Copy , Default , bytemuck :: Pod , bytemuck :: Zeroable)] pub struct InstanceInput { pub pos0 : [f32 ; 2usize] , pub pos1 : [f32 ; 2usize] , pub pos2 : [f32 ; 2usize] , pub color0 : [f32 ; 4usize] , pub color1 : [f32 ; 4usize] , pub color2 : [f32 ; 4usize] , pub uv0 : [f32 ; 2usize] , pub uv1 : [f32 ; 2usize] , pub uv2 : [f32 ; 2usize] , pub affine_t_x : [f32 ; 2usize] , pub affine_t_y : [f32 ; 2usize] , pub affine_offset : [f32 ; 2usize] , pub is_text : u32 , pub clip_poly : u32 } impl InstanceInput { pub fn new (pos0 : [f32 ; 2usize] , pos1 : [f32 ; 2usize] , pos2 : [f32 ; 2usize] , color0 : [f32 ; 4usize] , color1 : [f32 ; 4usize] , color2 : [f32 ; 4usize] , uv0 : [f32 ; 2usize] , uv1 : [f32 ; 2usize] , uv2 : [f32 ; 2usize] , affine_t_x : [f32 ; 2usize] , affine_t_y : [f32 ; 2usize] , affine_offset : [f32 ; 2usize] , is_text : u32 , clip_poly : u32) -> Self { Self { pos0 , pos1 , pos2 , color0 , color1 , color2 , uv0 , uv1 , uv2 , affine_t_x , affine_t_y , affine_offset , is_text , clip_poly } } } impl super :: super :: main :: structs :: InstanceInput { pub fn vertex_desc (step_mode : wgpu :: VertexStepMode) -> wgpu :: VertexBufferLayout < 'static > { wgpu :: VertexBufferLayout { array_stride : std :: mem :: size_of :: < Self > () as wgpu :: BufferAddress , step_mode , attributes : & [wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , pos0) as wgpu :: BufferAddress , shader_location : 1u32 , format : wgpu :: VertexFormat :: Float32x2 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , pos1) as wgpu :: BufferAddress , shader_location : 2u32 , format : wgpu :: VertexFormat :: Float32x2 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , pos2) as wgpu :: BufferAddress , shader_location : 3u32 , format : wgpu :: VertexFormat :: Float32x2 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , color0) as wgpu :: BufferAddress , shader_location : 4u32 , format : wgpu :: VertexFormat :: Float32x4 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , color1) as wgpu :: BufferAddress , shader_location : 5u32 , format : wgpu :: VertexFormat :: Float32x4 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , color2) as wgpu :: BufferAddress , shader_location : 6u32 , format : wgpu :: VertexFormat :: Float32x4 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , uv0) as wgpu :: BufferAddress , shader_location : 7u32 , format : wgpu :: VertexFormat :: Float32x2 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , uv1) as wgpu :: BufferAddress , shader_location : 8u32 , format : wgpu :: VertexFormat :: Float32x2 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , uv2) as wgpu :: BufferAddress , shader_location : 9u32 , format : wgpu :: VertexFormat :: Float32x2 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , affine_t_x) as wgpu :: BufferAddress , shader_location : 10u32 , format : wgpu :: VertexFormat :: Float32x2 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , affine_t_y) as wgpu :: BufferAddress , shader_location : 11u32 , format : wgpu :: VertexFormat :: Float32x2 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , affine_offset) as wgpu :: BufferAddress , shader_location : 12u32 , format : wgpu :: VertexFormat :: Float32x2 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , is_text) as wgpu :: BufferAddress , shader_location : 13u32 , format : wgpu :: VertexFormat :: Uint32 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , clip_poly) as wgpu :: BufferAddress , shader_location : 14u32 , format : wgpu :: VertexFormat :: Uint32 , }] , } } } # [allow (non_snake_case)] # [repr (C)] # [cfg_attr (debug_assertions , derive (Debug))] # [derive (PartialEq , Clone , Copy , Default , bytemuck :: Pod , bytemuck :: Zeroable)] pub struct VertexOutput { pos : [u8 ; const { 16usize }] , pub color : [f32 ; 4usize] , pub uv : [f32 ; 2usize] , pub is_text : u32 , pub clip_poly : u32 } impl VertexOutput { pub fn new (color : [f32 ; 4usize] , uv : [f32 ; 2usize] , is_text : u32 , clip_poly : u32) -> Self { Self { pos : [0 ; const { 16usize }] , color , uv , is_text , clip_poly } } } # [allow (non_snake_case)] # [repr (C , align (4))] # [cfg_attr (debug_assertions , derive (Debug))] # [derive (PartialEq , Clone , Copy , Default , bytemuck :: Pod , bytemuck :: Zeroable)] pub struct ClipPolygon { # [doc = "size: 4, offset: 0x0, type: `u32`"] pub start_point : u32 , # [doc = "size: 4, offset: 0x4, type: `u32`"] pub end_point : u32 , # [doc = "size: 4, offset: 0x8, type: `u32`"] pub parent : u32 } impl ClipPolygon { pub fn new (start_point : u32 , end_point : u32 , parent : u32) -> Self { Self { start_point , end_point , parent } } } } pub mod entries { pub const FRAG_ENTRY_FS_MAIN : & str = "fs_main" ; pub fn fragment_entry_fs_main < '__lt > (targets : & '__lt [:: core :: option :: Option < wgpu :: ColorTargetState >]) -> super :: super :: FragmentEntry < '__lt > { super :: super :: FragmentEntry { entry_point : FRAG_ENTRY_FS_MAIN , targets , } } pub const VERT_ENTRY_VS_MAIN : & str = "vs_main" ; # [allow (non_snake_case)] pub fn vertex_entry_vs_main (VertexInput_step_mode : wgpu :: VertexStepMode , InstanceInput_step_mode : wgpu :: VertexStepMode) -> super :: super :: VertexEntry < 2usize > { super :: super :: VertexEntry { entry_point : VERT_ENTRY_VS_MAIN , buffers : [super :: super :: main :: structs :: VertexInput :: vertex_desc (VertexInput_step_mode) , super :: super :: main :: structs :: InstanceInput :: vertex_desc (InstanceInput_step_mode)] , } } } pub const SOURCE : & str = "struct Globals {\n    screen_size: vec2<f32>,\n}\n\nstruct VertexInput {\n    @location(0) pos: vec2<f32>,\n}\n\nstruct InstanceInput {\n    @location(1) pos0_: vec2<f32>,\n    @location(2) pos1_: vec2<f32>,\n    @location(3) pos2_: vec2<f32>,\n    @location(4) color0_: vec4<f32>,\n    @location(5) color1_: vec4<f32>,\n    @location(6) color2_: vec4<f32>,\n    @location(7) uv0_: vec2<f32>,\n    @location(8) uv1_: vec2<f32>,\n    @location(9) uv2_: vec2<f32>,\n    @location(10) affine_t_x: vec2<f32>,\n    @location(11) affine_t_y: vec2<f32>,\n    @location(12) affine_offset: vec2<f32>,\n    @location(13) @interpolate(flat) is_text: u32,\n    @location(14) @interpolate(flat) clip_poly: u32,\n}\n\nstruct VertexOutput {\n    @builtin(position) pos: vec4<f32>,\n    @location(0) color: vec4<f32>,\n    @location(1) uv: vec2<f32>,\n    @location(2) @interpolate(flat) is_text: u32,\n    @location(3) @interpolate(flat) clip_poly: u32,\n}\n\nstruct ClipPolygon {\n    start_point: u32,\n    end_point: u32,\n    parent: u32,\n}\n\n@group(0) @binding(0) \nvar<uniform> GLOBALS: Globals;\n@group(2) @binding(0) \nvar TEXT_MASK_T: texture_2d<f32>;\n@group(2) @binding(2) \nvar TEXT_COLOR_T: texture_2d<f32>;\n@group(1) @binding(0) \nvar TEX_T: texture_2d<f32>;\n@group(1) @binding(1) \nvar TEX_S: sampler;\n@group(2) @binding(1) \nvar TEXT_MASK_S: sampler;\n@group(2) @binding(3) \nvar TEXT_COLOR_S: sampler;\n@group(3) @binding(0) \nvar<storage> CLIP_POLYGON_POINTS: array<vec2<f32>>;\n@group(3) @binding(1) \nvar<storage> CLIP_POLYGONS: array<ClipPolygon>;\n\nfn fs_color(in_1: VertexOutput) -> vec4<f32> {\n    var color: vec4<f32>;\n\n    if (in_1.uv.x <= -1f) {\n        return in_1.color;\n    } else {\n        switch in_1.is_text {\n            case 1u: {\n                color = in_1.color;\n                let _e14 = textureSampleLevel(TEXT_MASK_T, TEXT_MASK_S, in_1.uv, 0f);\n                let _e16 = color.w;\n                color.w = (_e16 * _e14.x);\n                let _e18 = color;\n                return _e18;\n            }\n            case 2u: {\n                let _e23 = textureSampleLevel(TEXT_COLOR_T, TEXT_COLOR_S, in_1.uv, 0f);\n                return (_e23 * in_1.color);\n            }\n            default: {\n                let _e30 = textureSampleLevel(TEX_T, TEX_S, in_1.uv, 0f);\n                return (_e30 * in_1.color);\n            }\n        }\n    }\n}\n\nfn point_in_poly(pos_1: vec2<f32>, poly: ClipPolygon) -> bool {\n    var c: bool = false;\n    var i_1: u32 = 0u;\n\n    let point_count = (poly.end_point - poly.start_point);\n    loop {\n        let _e7 = i_1;\n        if (_e7 < point_count) {\n        } else {\n            break;\n        }\n        {\n            let _e9 = i_1;\n            let idx1_ = (_e9 + poly.start_point);\n            let _e12 = i_1;\n            let idx2_ = (((_e12 + 1u) % point_count) + poly.start_point);\n            let a = CLIP_POLYGON_POINTS[idx1_];\n            let b = CLIP_POLYGON_POINTS[idx2_];\n            if ((pos_1.x == a.x) && (pos_1.y == a.y)) {\n                return true;\n            }\n            if ((a.y > pos_1.y) != (b.y > pos_1.y)) {\n                let slope = (((pos_1.x - a.x) * (b.y - a.y)) - ((b.x - a.x) * (pos_1.y - a.y)));\n                if (slope == 0f) {\n                    return true;\n                }\n                if ((slope < 0f) != (b.y < a.y)) {\n                    let _e65 = c;\n                    c = !(_e65);\n                }\n            }\n        }\n        continuing {\n            let _e68 = i_1;\n            i_1 = (_e68 + 1u);\n        }\n    }\n    let _e70 = c;\n    return _e70;\n}\n\n@vertex \nfn vs_main(@builtin(vertex_index) v_idx: u32, vertex: VertexInput, instance: InstanceInput) -> VertexOutput {\n    var out: VertexOutput;\n    var positions: array<vec2<f32>, 3>;\n    var colors: array<vec4<f32>, 3>;\n    var uvs: array<vec2<f32>, 3>;\n    var pos: vec2<f32>;\n\n    positions = array<vec2<f32>, 3>(instance.pos0_, instance.pos1_, instance.pos2_);\n    colors = array<vec4<f32>, 3>(instance.color0_, instance.color1_, instance.color2_);\n    uvs = array<vec2<f32>, 3>(instance.uv0_, instance.uv1_, instance.uv2_);\n    let _e21 = positions[v_idx];\n    pos = ((mat2x2<f32>(instance.affine_t_x, instance.affine_t_y) * _e21) + instance.affine_offset);\n    if (instance.is_text > 0u) {\n    }\n    let _e31 = pos;\n    let _e34 = GLOBALS.screen_size;\n    out.pos = vec4<f32>(((_e31 / _e34) * 2f), 0f, 1f);\n    let _e43 = colors[v_idx];\n    out.color = _e43;\n    let _e46 = uvs[v_idx];\n    out.uv = _e46;\n    switch instance.is_text {\n        case 1u: {\n            let _e50 = textureDimensions(TEXT_MASK_T);\n            let _e52 = out.uv;\n            out.uv = (_e52 / vec2<f32>(_e50));\n        }\n        case 2u: {\n            let _e56 = textureDimensions(TEXT_COLOR_T);\n            let _e58 = out.uv;\n            out.uv = (_e58 / vec2<f32>(_e56));\n        }\n        default: {\n        }\n    }\n    out.is_text = instance.is_text;\n    out.clip_poly = instance.clip_poly;\n    let _e64 = out;\n    return _e64;\n}\n\n@fragment \nfn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {\n    var antialias: array<vec2<f32>, 5> = array<vec2<f32>, 5>(vec2<f32>(-0.375f, 0.125f), vec2<f32>(0.125f, 0.375f), vec2<f32>(0.375f, -0.125f), vec2<f32>(-0.125f, -0.375f), vec2<f32>(0f, 0f));\n    var final_weight: f32 = 1f;\n    var clip_poly: u32;\n    var weight: f32;\n    var i: i32;\n\n    let _e13 = fs_color(in);\n    let _e18 = GLOBALS.screen_size;\n    let world_pos = ((in.pos.xy - (_e18 / vec2(2f))) * vec2<f32>(1f, -1f));\n    clip_poly = in.clip_poly;\n    loop {\n        let _e29 = clip_poly;\n        if (_e29 != 0u) {\n        } else {\n            break;\n        }\n        {\n            let _e33 = clip_poly;\n            let poly_1 = CLIP_POLYGONS[_e33];\n            weight = 0f;\n            i = 0i;\n            loop {\n                let _e40 = i;\n                if (_e40 < 5i) {\n                } else {\n                    break;\n                }\n                {\n                    let _e44 = i;\n                    let _e46 = antialias[_e44];\n                    let pos_2 = (world_pos + _e46);\n                    let _e48 = point_in_poly(pos_2, poly_1);\n                    if _e48 {\n                        let _e50 = weight;\n                        weight = (_e50 + 1f);\n                    }\n                }\n                continuing {\n                    let _e53 = i;\n                    i = (_e53 + 1i);\n                }\n            }\n            let _e55 = weight;\n            let _e59 = final_weight;\n            final_weight = (_e59 * (_e55 / 5f));\n            clip_poly = poly_1.parent;\n        }\n    }\n    let _e64 = final_weight;\n    return vec4<f32>(_e13.xyz, (_e13.w * _e64));\n}\n" ; pub fn create_pipeline_layout (device : & wgpu :: Device) -> wgpu :: PipelineLayout { device . create_pipeline_layout (& wgpu :: PipelineLayoutDescriptor { label : Some ("main::PipelineLayout") , bind_group_layouts : & [& super :: main :: globals :: BindGroup0 :: get_bind_group_layout (device) , & super :: main :: globals :: BindGroup1 :: get_bind_group_layout (device) , & super :: main :: globals :: BindGroup2 :: get_bind_group_layout (device) , & super :: main :: globals :: BindGroup3 :: get_bind_group_layout (device)] , push_constant_ranges : & [] , } ,) } pub fn create_shader_module (device : & wgpu :: Device) -> wgpu :: ShaderModule { device . create_shader_module (wgpu :: ShaderModuleDescriptor { label : Some ("main::ShaderModule") , source : wgpu :: ShaderSource :: Wgsl (self :: SOURCE . into ()) , }) }