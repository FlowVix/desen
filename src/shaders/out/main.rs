pub mod globals { # [allow (unused_imports)] pub use super :: * ; # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup1EntriesEntriesParams < '__lt > { pub TEX_T : & '__lt wgpu :: TextureView , pub TEX_S : & '__lt wgpu :: Sampler } # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup1Entries < '__lt > { pub TEX_T : wgpu :: BindGroupEntry < '__lt > , pub TEX_S : wgpu :: BindGroupEntry < '__lt > } impl < '__lt > BindGroup1Entries < '__lt > { pub fn new (params : BindGroup1EntriesEntriesParams < '__lt >) -> Self { Self { TEX_T : wgpu :: BindGroupEntry { binding : 0u32 , resource : wgpu :: BindingResource :: TextureView (params . TEX_T) } , TEX_S : wgpu :: BindGroupEntry { binding : 1u32 , resource : wgpu :: BindingResource :: Sampler (params . TEX_S) } } } } # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup1 (wgpu :: BindGroup) ; impl BindGroup1 { pub const INDEX : u32 = 1u32 ; # [allow (unused_doc_comments)] pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("main::BindGroup1::LayoutDescriptor") , entries : & [# [doc = "@binding(1): TEX_T"] wgpu :: BindGroupLayoutEntry { binding : 0u32 , visibility : wgpu :: ShaderStages :: VERTEX_FRAGMENT , ty : wgpu :: BindingType :: Texture { sample_type : wgpu :: TextureSampleType :: Float { filterable : true } , view_dimension : wgpu :: TextureViewDimension :: D2 , multisampled : false , } , count : None , } , # [doc = "@binding(1): TEX_S"] wgpu :: BindGroupLayoutEntry { binding : 1u32 , visibility : wgpu :: ShaderStages :: VERTEX_FRAGMENT , ty : wgpu :: BindingType :: Sampler (wgpu :: SamplerBindingType :: Filtering) , count : None , }] , } ; pub fn get_bind_group_layout (device : & wgpu :: Device) -> wgpu :: BindGroupLayout { device . create_bind_group_layout (& Self :: LAYOUT_DESCRIPTOR) } pub fn from_bindings (device : & wgpu :: Device , bindings : BindGroup1Entries ,) -> Self { let bind_group_layout = Self :: get_bind_group_layout (& device) ; let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("main::BindGroup1") , layout : & bind_group_layout , entries : & [bindings . TEX_T , bindings . TEX_S] , } ,) ; Self (bind_group) } pub fn get_bind_group (& self) -> & wgpu :: BindGroup { & self . 0 } } # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup0EntriesEntriesParams < '__lt > { pub GLOBALS : wgpu :: BufferBinding < '__lt > } # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup0Entries < '__lt > { pub GLOBALS : wgpu :: BindGroupEntry < '__lt > } impl < '__lt > BindGroup0Entries < '__lt > { pub fn new (params : BindGroup0EntriesEntriesParams < '__lt >) -> Self { Self { GLOBALS : wgpu :: BindGroupEntry { binding : 0u32 , resource : wgpu :: BindingResource :: Buffer (params . GLOBALS) } } } } # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup0 (wgpu :: BindGroup) ; impl BindGroup0 { pub const INDEX : u32 = 0u32 ; # [allow (unused_doc_comments)] pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("main::BindGroup0::LayoutDescriptor") , entries : & [# [doc = "@binding(0): GLOBALS"] wgpu :: BindGroupLayoutEntry { binding : 0u32 , visibility : wgpu :: ShaderStages :: VERTEX_FRAGMENT , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < super :: structs :: Globals > () as _) , } , count : None , }] , } ; pub fn get_bind_group_layout (device : & wgpu :: Device) -> wgpu :: BindGroupLayout { device . create_bind_group_layout (& Self :: LAYOUT_DESCRIPTOR) } pub fn from_bindings (device : & wgpu :: Device , bindings : BindGroup0Entries ,) -> Self { let bind_group_layout = Self :: get_bind_group_layout (& device) ; let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("main::BindGroup0") , layout : & bind_group_layout , entries : & [bindings . GLOBALS] , } ,) ; Self (bind_group) } pub fn get_bind_group (& self) -> & wgpu :: BindGroup { & self . 0 } } } pub mod constants { # [allow (unused_imports)] pub use super :: * ; } pub mod structs { # [allow (unused_imports)] pub use super :: * ; # [allow (non_snake_case)] # [repr (C , align (8))] # [cfg_attr (debug_assertions , derive (Debug))] # [derive (PartialEq , Clone , Copy , Default , bytemuck :: Pod , bytemuck :: Zeroable)] pub struct Globals { # [doc = "size: 8, offset: 0x0, type: `vec2<f32>`"] pub screen_size : [f32 ; 2usize] } impl Globals { pub fn new (screen_size : [f32 ; 2usize]) -> Self { Self { screen_size } } } # [allow (non_snake_case)] # [repr (C)] # [cfg_attr (debug_assertions , derive (Debug))] # [derive (PartialEq , Clone , Copy , Default , bytemuck :: Pod , bytemuck :: Zeroable)] pub struct VertexInput { pub pos : [f32 ; 2usize] } impl VertexInput { pub fn new (pos : [f32 ; 2usize]) -> Self { Self { pos } } } impl super :: super :: main :: structs :: VertexInput { pub fn vertex_desc (step_mode : wgpu :: VertexStepMode) -> wgpu :: VertexBufferLayout < 'static > { wgpu :: VertexBufferLayout { array_stride : std :: mem :: size_of :: < Self > () as wgpu :: BufferAddress , step_mode , attributes : & [wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , pos) as wgpu :: BufferAddress , shader_location : 0u32 , format : wgpu :: VertexFormat :: Float32x2 , }] , } } } # [allow (non_snake_case)] # [repr (C)] # [cfg_attr (debug_assertions , derive (Debug))] # [derive (PartialEq , Clone , Copy , Default , bytemuck :: Pod , bytemuck :: Zeroable)] pub struct InstanceInput { pub pos0 : [f32 ; 2usize] , pub pos1 : [f32 ; 2usize] , pub pos2 : [f32 ; 2usize] , pub color0 : [f32 ; 4usize] , pub color1 : [f32 ; 4usize] , pub color2 : [f32 ; 4usize] , pub uv0 : [f32 ; 2usize] , pub uv1 : [f32 ; 2usize] , pub uv2 : [f32 ; 2usize] , pub affine_t_x : [f32 ; 2usize] , pub affine_t_y : [f32 ; 2usize] , pub affine_offset : [f32 ; 2usize] } impl InstanceInput { pub fn new (pos0 : [f32 ; 2usize] , pos1 : [f32 ; 2usize] , pos2 : [f32 ; 2usize] , color0 : [f32 ; 4usize] , color1 : [f32 ; 4usize] , color2 : [f32 ; 4usize] , uv0 : [f32 ; 2usize] , uv1 : [f32 ; 2usize] , uv2 : [f32 ; 2usize] , affine_t_x : [f32 ; 2usize] , affine_t_y : [f32 ; 2usize] , affine_offset : [f32 ; 2usize]) -> Self { Self { pos0 , pos1 , pos2 , color0 , color1 , color2 , uv0 , uv1 , uv2 , affine_t_x , affine_t_y , affine_offset } } } impl super :: super :: main :: structs :: InstanceInput { pub fn vertex_desc (step_mode : wgpu :: VertexStepMode) -> wgpu :: VertexBufferLayout < 'static > { wgpu :: VertexBufferLayout { array_stride : std :: mem :: size_of :: < Self > () as wgpu :: BufferAddress , step_mode , attributes : & [wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , pos0) as wgpu :: BufferAddress , shader_location : 1u32 , format : wgpu :: VertexFormat :: Float32x2 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , pos1) as wgpu :: BufferAddress , shader_location : 2u32 , format : wgpu :: VertexFormat :: Float32x2 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , pos2) as wgpu :: BufferAddress , shader_location : 3u32 , format : wgpu :: VertexFormat :: Float32x2 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , color0) as wgpu :: BufferAddress , shader_location : 4u32 , format : wgpu :: VertexFormat :: Float32x4 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , color1) as wgpu :: BufferAddress , shader_location : 5u32 , format : wgpu :: VertexFormat :: Float32x4 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , color2) as wgpu :: BufferAddress , shader_location : 6u32 , format : wgpu :: VertexFormat :: Float32x4 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , uv0) as wgpu :: BufferAddress , shader_location : 7u32 , format : wgpu :: VertexFormat :: Float32x2 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , uv1) as wgpu :: BufferAddress , shader_location : 8u32 , format : wgpu :: VertexFormat :: Float32x2 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , uv2) as wgpu :: BufferAddress , shader_location : 9u32 , format : wgpu :: VertexFormat :: Float32x2 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , affine_t_x) as wgpu :: BufferAddress , shader_location : 10u32 , format : wgpu :: VertexFormat :: Float32x2 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , affine_t_y) as wgpu :: BufferAddress , shader_location : 11u32 , format : wgpu :: VertexFormat :: Float32x2 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , affine_offset) as wgpu :: BufferAddress , shader_location : 12u32 , format : wgpu :: VertexFormat :: Float32x2 , }] , } } } # [allow (non_snake_case)] # [repr (C)] # [cfg_attr (debug_assertions , derive (Debug))] # [derive (PartialEq , Clone , Copy , Default , bytemuck :: Pod , bytemuck :: Zeroable)] pub struct VertexOutput { pos : [u8 ; const { 16usize }] , pub color : [f32 ; 4usize] , pub uv : [f32 ; 2usize] } impl VertexOutput { pub fn new (color : [f32 ; 4usize] , uv : [f32 ; 2usize]) -> Self { Self { pos : [0 ; const { 16usize }] , color , uv } } } } pub mod entries { pub const FRAG_ENTRY_FS_MAIN : & str = "fs_main" ; pub fn fragment_entry_fs_main < '__lt > (targets : & '__lt [:: core :: option :: Option < wgpu :: ColorTargetState >]) -> super :: super :: FragmentEntry < '__lt > { super :: super :: FragmentEntry { entry_point : FRAG_ENTRY_FS_MAIN , targets , } } pub const VERT_ENTRY_VS_MAIN : & str = "vs_main" ; # [allow (non_snake_case)] pub fn vertex_entry_vs_main (VertexInput_step_mode : wgpu :: VertexStepMode , InstanceInput_step_mode : wgpu :: VertexStepMode) -> super :: super :: VertexEntry < 2usize > { super :: super :: VertexEntry { entry_point : VERT_ENTRY_VS_MAIN , buffers : [super :: super :: main :: structs :: VertexInput :: vertex_desc (VertexInput_step_mode) , super :: super :: main :: structs :: InstanceInput :: vertex_desc (InstanceInput_step_mode)] , } } } pub const SOURCE : & str = "struct Globals {\n    screen_size: vec2<f32>,\n}\n\nstruct VertexInput {\n    @location(0) pos: vec2<f32>,\n}\n\nstruct InstanceInput {\n    @location(1) pos0_: vec2<f32>,\n    @location(2) pos1_: vec2<f32>,\n    @location(3) pos2_: vec2<f32>,\n    @location(4) color0_: vec4<f32>,\n    @location(5) color1_: vec4<f32>,\n    @location(6) color2_: vec4<f32>,\n    @location(7) uv0_: vec2<f32>,\n    @location(8) uv1_: vec2<f32>,\n    @location(9) uv2_: vec2<f32>,\n    @location(10) affine_t_x: vec2<f32>,\n    @location(11) affine_t_y: vec2<f32>,\n    @location(12) affine_offset: vec2<f32>,\n}\n\nstruct VertexOutput {\n    @builtin(position) pos: vec4<f32>,\n    @location(0) color: vec4<f32>,\n    @location(1) uv: vec2<f32>,\n}\n\n@group(0) @binding(0) \nvar<uniform> GLOBALS: Globals;\n@group(1) @binding(0) \nvar TEX_T: texture_2d<f32>;\n@group(1) @binding(1) \nvar TEX_S: sampler;\n\nfn fs_color(in_1: VertexOutput) -> vec4<f32> {\n    if (in_1.uv.x <= -1f) {\n        return in_1.color;\n    } else {\n        let _e10 = textureSampleLevel(TEX_T, TEX_S, in_1.uv, 0f);\n        return (_e10 * in_1.color);\n    }\n}\n\n@vertex \nfn vs_main(@builtin(vertex_index) v_idx: u32, vertex: VertexInput, instance: InstanceInput) -> VertexOutput {\n    var out: VertexOutput;\n    var positions: array<vec2<f32>, 3>;\n    var colors: array<vec4<f32>, 3>;\n    var uvs: array<vec2<f32>, 3>;\n\n    positions = array<vec2<f32>, 3>(instance.pos0_, instance.pos1_, instance.pos2_);\n    colors = array<vec4<f32>, 3>(instance.color0_, instance.color1_, instance.color2_);\n    uvs = array<vec2<f32>, 3>(instance.uv0_, instance.uv1_, instance.uv2_);\n    let _e21 = positions[v_idx];\n    let pos = ((mat2x2<f32>(instance.affine_t_x, instance.affine_t_y) * _e21) + instance.affine_offset);\n    let _e29 = GLOBALS.screen_size;\n    out.pos = vec4<f32>(((pos / _e29) * 2f), 0f, 1f);\n    let _e38 = colors[v_idx];\n    out.color = _e38;\n    let _e41 = uvs[v_idx];\n    out.uv = _e41;\n    let _e42 = out;\n    return _e42;\n}\n\n@fragment \nfn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {\n    let _e1 = fs_color(in);\n    return vec4<f32>(_e1.xyz, _e1.w);\n}\n" ; pub fn create_pipeline_layout (device : & wgpu :: Device) -> wgpu :: PipelineLayout { device . create_pipeline_layout (& wgpu :: PipelineLayoutDescriptor { label : Some ("main::PipelineLayout") , bind_group_layouts : & [& super :: main :: globals :: BindGroup0 :: get_bind_group_layout (device) , & super :: main :: globals :: BindGroup1 :: get_bind_group_layout (device)] , push_constant_ranges : & [] , } ,) } pub fn create_shader_module (device : & wgpu :: Device) -> wgpu :: ShaderModule { device . create_shader_module (wgpu :: ShaderModuleDescriptor { label : Some ("main::ShaderModule") , source : wgpu :: ShaderSource :: Wgsl (self :: SOURCE . into ()) , }) }